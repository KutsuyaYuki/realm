---
title: "Advanced Typescript: A Concise Explanation"
date: "2023-08-01"
desc: "Some stuffs you probably don't know about Typescript."
tags:
  - "typescript"
permalink: "/posts/typescript-advanced"
---

## Abstract

Typescript is a powerful tool that can help you write better JavaScript. How? It does that by implementing a type system that allows you to write a robust and check errors before they're even shipped. It's a wonderful tool that I use in my day-to-day work. However, there are some features that I don't use that often, and I'm sure you don't either. So, let's dive into some of them.

## Union and Intersection Types

Say you have an variable that can be either a `string` or a `number`. How would you type that? No, don't bring `any` into this. That's a bad practice. Instead, you can use something called _a union type_.

```ts
type StringOrNumber = string | number;

const foo: StringOrNumber = "bar"; // ✅ Correct typings
const bar: StringOrNumber = 123; // ✅ Correct typings
const baz: StringOrNumber = true; // ❌ boolean is not string or number
```

As you can see, you can use the `|` operator to create a union type. This is useful when you want to create a type that can be one of many types. However, what if you want to create a type that is a combination of two types? That's where _intersection types_ come in.

```ts
type Person = {
  name: string;
  age: number;
};

type Employee = {
  company: string;
  position: string;
};

type EmployeePerson = Person & Employee;

const employee: EmployeePerson = {
  name: "John Doe",
  age: 30,
  company: "Google",
  position: "Software Engineer",
}; // ✅ This employee has all the properties of Person and Employee

const employee2: EmployeePerson = {
  name: "John Doe",
  age: 30,
}; // ❌ This employee does not have all the properties of Person and Employee
```

Say you need to create a type that is a combination of two types but is also a union of two types. You can do that by combining union and intersection types.

```ts
type Person = {
  name: string;
  age: number;
};

type Employee = {
  company: string;
  position: string;
};

type Owner = {
  shares: number;
};

type User = Person & (Employee | Owner);

const user: User = {
  name: "John Doe",
  age: 30,
  company: "Google",
  position: "Software Engineer",
}; // ✅ This user has company and position as properties, therefore it is an Employee

const user2: User = {
  name: "John Doe",
  age: 30,
  shares: 100,
}; // ✅ This user has shares as a property, therefore it is an Owner

const user3: User = {
  name: "John Doe",
  age: 30,
}; // ❌ You need to have either company and position or shares as properties

const user4: User = {
  name: "John Doe",
  age: 30,
  company: "Google",
  position: "Software Engineer",
  shares: 100,
}; // ❌ You can't have both company and position and shares as properties
```

You can also make a union of strings that emulates something akin to an enum. Check out the example below.

```ts
type Color = "red" | "green" | "blue";

const color: Color = "red"; // ✅ "red" exists in the union type
const color2: Color = "yellow"; // ❌ "yellow" does not exist in the union type
```

## Generics

Generics are a way to create reusable components. They allow you to create a component that can work over a variety of types rather than a single one. Let's take a look at an example.

```ts
type Foo<T> = {
  bar: T;
};

const foo: Foo<string> = {
  bar: "baz",
}; // ✅ Correct typings

const foo2: Foo<number> = {
  bar: 123,
}; // ✅ Correct typings

const foo3: Foo<boolean> = {
  bar: true,
}; // ✅ Correct typings

const foo4: Foo<string> = {
  bar: 123,
}; // ❌ number is not string
```

You can also declare multiple generic types such as the example below.

```ts
type Foo<T, U> = {
  bar: T;
  baz: U;
};

const foo: Foo<string, number> = {
  bar: "baz",
  baz: 123,
}; // ✅ Correct typings

const foo2: Foo<number, boolean> = {
  bar: "baz",
  baz: true,
}; // ❌ number is not string
```

## Keyof Operator

Now that we know how to create generic types, union types, and intersection types, let's take a look at the `keyof` operator. This operator allows you to get the keys of a type and return it as a union type. Let's take a look at an example.

```ts
type Article {
  title: string;
  content: string;
  published: boolean;
  draft: boolean;
}

type ArticleKeys = keyof Article;
// this is the same as:
type ArticleKeys = "title" | "content" | "published" | "draft";
```

## Typeof Operator

The `typeof` operator allows you to get the type of a variable. Let's take a look at an example.

```ts
const foo = "bar";

type FooType = typeof foo;
// this is the same as:
type FooType = string;
```

Say you have an object whose type is unknown to you and you want to get the union type of the properties and use it somewhere else. You can do that by using the combination of `keyof` and `typeof` operator.

```ts
const weDontKnowTheType = {
  foo: "bar",
  bar: 123,
  baz: true,
};

type TryToKnowTheType = keyof typeof weDontKnowTheType;
// this is the same as:
type TryToKnowTheType = "foo" | "bar" | "baz";
```

## Conditional Types

Say you want to create a type that is dependent on another type. You can do that by using conditional types. Let's take a look at an example.

```ts
type Foo<T> = T extends string ? string : number;

let foo: Foo<string> = "bar"; // ✅ Correct typings
let foo2: Foo<number> = 123; // ✅ number is not string, therefore the proper type is number
let foo3: Foo<boolean> = true; // ❌ boolean is not string, therefore the proper type is number
```

## Type Inference

Type inference is a way to infer the type of a variable based on its usage. Let's take a look at an example.

```ts
let foo = "bar"; // TypeScript infers that foo is a string

foo = 123; // ❌ foo is a string and not a number
foo = "baz"; // ✅ self-explanatory
```

The `Foo` type from the previous conditional types example is dependent on the type of `T`. If `T` is a `string`, then `Foo<T>` is a `string`. Otherwise, it's a `number`. You can also use the `infer` keyword to infer the type of `T`. Let's take a look at an example.

```ts
type Foo<T> = T extends string ? string : number;

type Bar<T> = T extends Foo<infer U> ? U : boolean;

let bar: Bar<Foo<string>> = "baz"; // ✅ The type of U is string.
let bar2: Bar<Foo<number>> = 123; // ✅ The type of U is number.
let bar3: Bar<Foo<boolean>> = true; // ✅ The type of U is boolean.
let bar4: Bar<Foo<boolean>> = "baz";
// ❌ The type of U is boolean.
// Therefore, bar4 should be a boolean since Foo<boolean> is a number and not the same type as U.
```

## Utility Types

TypeScript comes with a bunch of utility types that you can use to create new types. You don't need to import them. They are available out of the box. Let's take a look at some of them.

### Partial

The `Partial` type allows you to make all the properties of a type optional. Let's take a look at an example.

```ts
type Foo = {
  bar: string;
  baz: number;
};

type PartialFoo = Partial<Foo>;

const foo: PartialFoo = {
  bar: "baz",
}; // ✅ All properties are optional. You can omit them if you want.
```

### Required

The `Required` type allows you to make all the properties of a type required. Let's take a look at an example.

```ts
type Foo = {
  bar?: string;
  baz?: number;
};

type RequiredFoo = Required<Foo>;

const foo: RequiredFoo = {
  bar: "baz",
  baz: 123,
}; // ✅ All properties are required.

const foo2: RequiredFoo = {
  bar: "baz",
}; // ❌ Property 'baz' is missing in type '{ bar: string; }' but required in type 'RequiredFoo'.
```

### Readonly

The `Readonly` type allows you to make all the properties of a type readonly. Let's take a look at an example.

```ts
type Foo = {
  bar: string;
  baz: number;
};

type ReadonlyFoo = Readonly<Foo>;

const foo: ReadonlyFoo = {
  bar: "baz",
  baz: 123,
};

const foo2: Foo = {
  bar: "baz",
  baz: 123,
};

foo2.bar = "baz"; // ✅ Object is mutable.
foo.bar = "baz"; // ❌ Cannot assign to 'bar' because it is a read-only property.
```

### Extract

The `Extract` type allows you to extract a subset of a type. Let's take a look at an example.

```ts
type Characters =
  | "a"
  | "b"
  | 1
  | 2
  | {
      foo: string;
      bar: string;
    };

type ExtractCharacters = Extract<Characters, string>;
// this is the same as:
type ExtractCharacters = "a" | "b";

const foo: ExtractCharacters = "a"; // ✅ Correct typings
const foo2: ExtractCharacters = 1; // ❌ number is not string

type ExtractNumbers = Extract<Characters, number>;
// this is the same as:
type ExtractNumbers = 1 | 2;

const foo3: ExtractNumbers = 1; // ✅ Correct typings
const foo4: ExtractNumbers = "a"; // ❌ string is not number

type ExtractObjects = Extract<Characters, { foo: string }>;
// this is the same as:
type ExtractObjects = {
  foo: string;
  bar: string;
};

const foo5: ExtractObjects = {
  foo: "bar",
  bar: "baz",
}; // ✅ Correct typings

const foo6: ExtractObjects = "a"; // ❌ string is not an object of type { foo: string; bar: string; }
```

`Extract<Characters, string>` creates a union type consists of only strings. `Extract<Characters, number>` creates a union type consists of only numbers. `Extract<Characters, { foo: string }>` creates a union type consists of only objects that have a `foo` property of type `string`.

### Exclude

The `Exclude` type allows you to exclude a subset of a type. Let's take a look at an example.

```ts
type Characters =
  | "a"
  | "b"
  | 1
  | 2
  | {
      foo: string;
      bar: string;
    };

type ExcludeCharacters = Exclude<Characters, string>;
// this is the same as:
type ExcludeCharacters =
  | 1
  | 2
  | {
      foo: string;
      bar: string;
    };

const foo: ExcludeCharacters = 1; // ✅ Correct typings
const foo2: ExcludeCharacters = "a"; // ❌ string is not number or object of type { foo: string; bar: string; }

type ExcludeNumbers = Exclude<Characters, number>;
// this is the same as:
type ExcludeNumbers =
  | "a"
  | "b"
  | {
      foo: string;
      bar: string;
    };

const foo3: ExcludeNumbers = "a"; // ✅ Correct typings
const foo4: ExcludeNumbers = 1; // ❌ number is not string or object of type { foo: string; bar: string; }

type ExcludeObjects = Exclude<Characters, { foo: string }>;
// this is the same as:
type ExcludeObjects = "a" | "b" | 1 | 2;

const foo5: ExcludeObjects = 1; // ✅ Correct typings
const foo6: ExcludeObjects = "a"; // ✅ Correct typings
const foo7: ExcludeObjects = {
  foo: "bar",
  bar: "baz",
}; // ❌ object of type { foo: string; bar: string; } is not number or string
```

`Exclude<Characters, string>` creates a union type consists of everything except strings. `Exclude<Characters, number>` creates a union type consists of everything except numbers. `Exclude<Characters, { foo: string }>` creates a union type consists of everything except objects that have a `foo` property of type `string`.

### Omit

The `Omit` type allows you to omit a subset of a type. Let's take a look at an example.

```ts
type Foo = {
  bar: string;
  baz: number;
};

type OmitFoo = Omit<Foo, "bar">;
// this is the same as:
type OmitFoo = {
  baz: number;
};

const foo: OmitFoo = {
  baz: 123,
}; // ✅ Correct typings

const foo2: OmitFoo = {
  bar: "baz",
  baz: 123,
}; // ❌ Property 'bar' is missing in type '{ bar: string; baz: number; }' but required in type 'OmitFoo'.
```

### Pick

The `Pick` type allows you to pick a subset of a type. Let's take a look at an example.

```ts
type Foo = {
  bar: string;
  baz: number;
};

type PickFoo = Pick<Foo, "bar">;
// this is the same as:
type PickFoo = {
  bar: string;
};

const foo: PickFoo = {
  bar: "baz",
}; // ✅ Correct typings

const foo2: PickFoo = {
  bar: "baz",
  baz: 123,
}; // ❌ Object literal may only specify known properties, and 'baz' does not exist in type 'PickFoo'.
```

### Record

The `Record` type allows you to create a type with a set of properties of a certain type. Let's take a look at an example.

```ts
type Foo = Record<"bar" | "baz", string>;
// this is the same as:
type Foo = {
  bar: string;
  baz: string;
};

const foo: Foo = {
  bar: "baz",
  baz: "baz",
}; // ✅ Correct typings

const foo2: Foo = {
  bar: "baz",
  baz: 123,
}; // ❌ Type 'number' is not assignable to type 'string'.
```

### NonNullable

The `NonNullable` type allows you to create a type without `null` and `undefined`. Let's take a look at an example.

```ts
type Foo = string | null | undefined;

type NonNullableFoo = NonNullable<Foo>;
// this is the same as:
type NonNullableFoo = string;

const foo: NonNullableFoo = "baz"; // ✅ Correct typings

const foo2: NonNullableFoo = null; // ❌ Type 'null' is not assignable to type 'string'.

const foo3: NonNullableFoo = undefined; // ❌ Type 'undefined' is not assignable to type 'string'.
```

### Parameters

The `Parameters` type allows you to get the parameters of a function into an array type. Let's take a look at an example.

```ts
type Foo = (bar: string, baz: number) => void;

type ParametersFoo = Parameters<Foo>;
// this is the same as:
type ParametersFoo = [bar: string, baz: number];

const foo: ParametersFoo = ["baz", 123]; // ✅ Correct typings

const foo2: ParametersFoo = ["baz", "baz"]; // ❌ Type 'string' is not assignable to type 'number'.
```

### ConstructorParameters

The `ConstructorParameters` type allows you to get the parameters of a constructor function into an array type. Let's take a look at an example.

```ts
class Foo {
  constructor(bar: string, baz: number) {}
}

type ConstructorParametersFoo = ConstructorParameters<typeof Foo>;

const foo: ConstructorParametersFoo = ["baz", 123]; // ✅ Correct typings

const foo2: ConstructorParametersFoo = ["baz", "baz"]; // ❌ Type 'string' is not assignable to type 'number'.
```

### ReturnType

The `ReturnType` type allows you to get the return type of a function. Let's take a look at an example.

```ts
type Foo = () => string;

type ReturnTypeFoo = ReturnType<Foo>;
// this is the same as:
type ReturnTypeFoo = string;

const foo: ReturnTypeFoo = "baz"; // ✅ Correct typings

const foo2: ReturnTypeFoo = 123; // ❌ Type 'number' is not assignable to type 'string'.
```

### Intrinsic String Manipulation Types

The intrinsic string manipulation types allow you to manipulate string types. There are 4 intrinsic string manipulation types: `Uppercase`, `Lowercase`, `Capitalize`, and `Uncapitalize`. Let's take a look at an example.

```ts
type Foo = "bar";

type UppercaseFoo = Uppercase<Foo>;

const foo: UppercaseFoo = "BAR"; // ✅ Correct typings

const foo2: UppercaseFoo = "bar"; // ❌ Type '"bar"' is not assignable to type '"BAR"'.

type LowercaseFoo = Lowercase<Foo>;

const foo3: LowercaseFoo = "bar"; // ✅ Correct typings

const foo4: LowercaseFoo = "BAR"; // ❌ Type '"BAR"' is not assignable to type '"bar"'.

type CapitalizeFoo = Capitalize<Foo>;

const foo5: CapitalizeFoo = "Bar"; // ✅ Correct typings

const foo6: CapitalizeFoo = "bar"; // ❌ Type '"bar"' is not assignable to type '"Bar"'.

type UncapitalizeFoo = Uncapitalize<Foo>;

const foo7: UncapitalizeFoo = "bar"; // ✅ Correct typings

const foo8: UncapitalizeFoo = "Bar"; // ❌ Type '"Bar"' is not assignable to type '"bar"'.
```

### Promise Value Types (Awaited)

The promise value types allow you to get the value type of a promise. This is useful when you have a promise that resolves to a certain type and you want to use that type. Let's take a look at an example.

```ts
type Foo = Promise<number>;

const sum = async (a: number, b: number): Foo => {
  return a + b;
};

const foo: Awaited<Foo> = await sum(1, 2); // ✅ Correct typings

const foo2: Awaited<Foo> = sum(1, 2); // ❌ Type 'Promise<number>' is not assignable to type 'number'.
```

> This utility type is meant to be used with the `await` keyword or in a `.then()` callback chain. If you try to use it without `await` or in a `.then()` callback chain, you will get an error.

## Mapped Types

Say you have a type that you want to change the properties of. Mapped types are a great way to do this. Mapped types are actually powerful as it allows you to define your own utility types easily. Let's take a look at an example.

```ts
type Foo = {
  bar: string;
  baz: number;
};

type TurnBool<T> = {
  [K in keyof T]: boolean;
};

type FooBool = TurnBool<Foo>;
// this is the same as:
type FooBool = {
  bar: boolean;
  baz: boolean;
};

const foo: FooBool = {
  bar: true,
  baz: false,
}; // ✅ Correct typings

const foo2: FooBool = {
  bar: "baz",
  baz: 123,
}; // ❌ Type 'string' is not assignable to type 'boolean'.
```

## Reusing everything

Now that we have learned about all of the utility types, let's take a look at how we can reuse everything we have learned. To be honest with you, the sky's the limit. You can combine all of the advanced features of Typescript to create your own ultimate type. Let's take a look at an example.

```ts
type nameOnly<Type> = {
  [Property in keyof Type as Exclude<Property, "firstname">]: Type[Property];
};

type Character = {
  firstname: string;
  name: string;
};

type character = nameOnly<Character>;

const character: character = {
  name: "John Doe",
}; // ✅ Correct typings

const character2: character = {
  firstname: "John",
  name: "John Doe",
}; // ❌ firstname is excluded from the type
```

## Conclusion

I hope you learned something new about Typescript from this post. Sure, it's a lot to take in, but I hope you can use this post as a reference for when you need to use these utility types. If you have any questions, feel free to reach out to me on [Telegram](https://t.me/lapplund). Thanks for reading!
