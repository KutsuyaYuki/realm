---
title: "Why MDX Is Cool: A Review"
date: "2023-03-29"
description: "As far as I can be."
tags:
  - "life"
  - "shorts"
layout: "../../layouts/Post.astro"
---

import CounterComponent from "../../components/CounterDemo";
import ToDoList from "../../components/ToDoList";
import MusicPlayer from "../../components/MusicPlayer";

## Introduction

So, I've been using MDX for a while now, and I've been meaning to write a review on it. So let's not waste time and get
right into it.

## What is MDX?

MDX (short for Markdown + JSX) is a markup language that combines the simplicity of Markdown with the power of JSX,
which is a syntax extension for JavaScript. MDX is used in web development to write content that includes interactive
components, such as charts or forms, alongside regular text content.

MDX allows developers to write components in JavaScript and use them within the Markdown syntax. This makes it easy to
create dynamic and interactive content, without having to switch between different languages or tools. MDX can be used
with a variety of front-end frameworks, including React, Vue, and Angular.

MDX is particularly useful for creating documentation, tutorials, or blog posts that require a mix of text content and
interactive components. With MDX, developers can create engaging and informative content that goes beyond plain text
and images.

## Why is MDX cool?

Say, you're writing a blog post and you want to include a counter component that can be used to increment or
decrement a number.

With MDX, you can write the component in JSX and then use it within the Markdown syntax. This makes it easy to
create dynamic and interactive content, without having to switch between different languages or tools.

Here's an example of a SolidJS counter component:

```tsx
import { createSignal } from "solid-js";

export default function CounterDemo() {
  const [count, setCount] = createSignal(0);

  return (
    <div class="flex justify-between items-center p-3 not-prose bg-neutral-800 rounded border-neutral-700 border">
      <button
        class="font-mono font-bold text-2xl bg-neutral-900 border-neutral-700 rounded border px-5 py-3"
        onClick={() => setCount(count() - 1)}
      >
        -
      </button>
      <p class="w-full text-center text-4xl">{count()}</p>
      <button
        class="font-mono font-bold text-2xl bg-neutral-900 border-neutral-700 rounded border px-5 py-3"
        onClick={() => setCount(count() + 1)}
      >
        +
      </button>
    </div>
  );
}
```

Here's how I would implement it in MDX:

```mdx
import CounterComponent from "./CounterDemo";

## Counter Demo

A simple counter component that displays an increment button and a counter.

<CounterComponent />
```

As a demonstration, my website already has it implemented, here's how it looks:

<CounterComponent client:visible />

Not satisfied yet? Say that I want to make a todo list that can be used to add and remove items.

I want it to use local storage to save the list, so that it can be used in multiple sessions as long
as you don't clear your browser's local storage.

I also want it to be able to be used in multiple pages, so I'll make it a component.

Here's the SolidJS code:

```tsx
import { createSignal, createEffect } from "solid-js";

export default function ToDoList() {
  const [todos, setTodos] = createSignal<string[]>([]);

  createEffect(() => {
    const todos = JSON.parse(localStorage.getItem("todos") || "[]");
    setTodos(todos);
  });

  return (
    <div class="flex flex-col bg-neutral-800 rounded border border-neutral-700 p-3 items-center justify-center h-full">
      <div class="flex flex-col gap-3 items-center justify-center w-full">
        <input
          class="w-full p-3 rounded border border-neutral-700 bg-neutral-900 text-neutral-100"
          type="text"
          placeholder="Add a new to do (press enter to add)"
          onKeyUp={(e) => {
            if (e.key === "Enter") {
              const current = e.currentTarget as HTMLInputElement;
              setTodos([...todos(), current.value]);
              localStorage.setItem("todos", JSON.stringify(todos()));
              e.currentTarget.value = "";
            }
          }}
        />
        {todos().length !== 0 && (
          <div class="flex flex-col gap-3 items-center justify-center w-full">
            {todos().map((todo) => (
              <div class="flex justify-between w-full items-center p-3 not-prose bg-neutral-900 rounded border-neutral-700 border">
                <p class="pl-2">{todo}</p>
                <button
                  class="hover:bg-opacity-50 transition bg-neutral-800 border-neutral-700 rounded border px-4 py-1"
                  onClick={() => {
                    setTodos(todos().filter((t) => t !== todo));
                    localStorage.setItem("todos", JSON.stringify(todos()));
                  }}
                >
                  Delete
                </button>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
```

Here's how I would implement it in MDX:

```mdx
import ToDoList from "./ToDoList";

## Todo List

A simple todo list that uses local storage to save the list.

<ToDoList />
```

Here's how it looks:

<ToDoList client:visible />

Oh, so you want something a bit more hard, huh? Say, I want to embed a music player with an actual music in it.

I want it to be able to play and pause it. Yeah, just like that for the time being.

Here's the SolidJS code:

```tsx
import { createSignal, createEffect } from "solid-js";
import { Play, Pause, Square } from "lucide-solid";

export default function MusicPlayer(props: {
  src: string;
  title: string;
  artist: string;
  album: string;
}) {
  const [playing, setPlaying] = createSignal(false);
  const [currentTime, setCurrentTime] = createSignal(0);
  const [duration, setDuration] = createSignal(0);
  const [volume, setVolume] = createSignal(1);
  const [muted, setMuted] = createSignal(false);
  const [loop, setLoop] = createSignal(false);
  const [audio, setAudio] = createSignal<HTMLAudioElement>();

  createEffect(() => {
    const audio = new Audio(props.src);
    audio.volume = volume();
    audio.loop = loop();
    audio.muted = muted();
    audio.onloadedmetadata = () => {
      setDuration(audio.duration);
    };
    audio.ontimeupdate = () => {
      setCurrentTime(audio.currentTime);
    };
    audio.onended = () => {
      setPlaying(false);
    };
    setAudio(audio);
  });

  return (
    <div class="flex not-prose flex-col w-full bg-neutral-800 rounded border border-neutral-700 items-center justify-center h-full">
      <div class="flex w-full bg-neutral-900 px-5 py-3">
        <div class="w-full flex justify-between items-center">
          <div class="flex w-full flex-col">
            <p class="text-neutral-200 font-heading">{props.title}</p>
            <p class="text-neutral-200 text-sm">{props.artist}</p>
            <p class="text-neutral-200 text-sm">{props.album}</p>
          </div>
          <div class="flex items-center gap-3">
            {playing() ? (
              <button
                class="hover:bg-opacity-50 transition bg-neutral-800 border-neutral-700 rounded-full border p-4"
                onClick={() => {
                  audio()?.pause();
                  setPlaying(false);
                }}
              >
                <Pause size={20} />
              </button>
            ) : (
              <button
                class="hover:bg-opacity-50 transition bg-neutral-800 border-neutral-700 rounded-full border p-4"
                onClick={() => {
                  audio()?.play();
                  setPlaying(true);
                }}
              >
                <Play size={20} />
              </button>
            )}
            <button
              class="hover:bg-opacity-50 transition bg-neutral-800 border-neutral-700 rounded-full border p-4"
              onClick={() => {
                audio()?.pause();
                audio()!.currentTime = 0;
                setPlaying(false);
              }}
            >
              <Square size={20} />
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}
```

Here's how I- at this point y'all already know how anyways.

Here's how it looks:

<MusicPlayer
  client:visible
  src="/audio/testaudio.mp3"
  title="Faster"
  artist="Razihel"
  album="-"
/>

> Attributions: [Link to the original source of the music](http://ncs.io/Faster)

## Conclusion

MDX is a powerful and versatile markup language that has gained popularity among web developers for its ability to
combine the simplicity of Markdown with the flexibility of JSX. As a language, MDX allows developers to seamlessly
integrate interactive components with text content, making it an excellent choice for creating engaging and informative
web content.

One of the most significant advantages of MDX is its compatibility with various front-end frameworks, including React,
Vue, and Angular. This means that developers can leverage their existing skills and knowledge to create dynamic and
interactive content that enhances the user experience.

MDX's flexibility also makes it an excellent choice for creating documentation, tutorials, or blog posts. By combining
text content with interactive components, developers can provide a richer and more engaging learning experience for
their audience.

Overall, MDX is an excellent choice for developers who want to create dynamic and interactive content that goes beyond
plain text and images. Its flexibility and compatibility with popular front-end frameworks make it a valuable tool in
any web developer's toolkit.
